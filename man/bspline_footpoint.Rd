% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bspline_footpoint.R
\name{bspline_footpoint}
\alias{bspline_footpoint}
\title{Footpoint computation}
\usage{
bspline_footpoint(
  x,
  c_point,
  u = NULL,
  degree = 3,
  tolerance = 1e-09,
  step = 0.2,
  initial.scan.points = nrow(c_point) * 8,
  knots = seq(from = 0, to = 1, length.out = nrow(c_point) - degree + 1),
  verbose = FALSE,
  prompt.mode = "distance",
  prompt.begin = 0,
  prompt.end = 1,
  algorithm = "Rogers",
  max.iterations = 100,
  alpha = 0,
  vz = c(0, 0, 1),
  ...
)
}
\arguments{
\item{x}{The matrix of row-vector positions that correspond to the data points.}

\item{c_point}{The matrix of row-vector positions that correspond to the control points.}

\item{u}{The initial parameter values that will be improved, equal to the number of rows in \code{x}. If 
NULL one is provided by default.}

\item{degree}{The spline polynomial degree.}

\item{tolerance}{The value below which the numerical approximation will exit.}

\item{step}{This factor controls how much of the parameter increase resulting from each round in the Newton-Raphson
minimization is actually being applied for the next round.}

\item{initial.scan.points}{The number of evenly distributed points onto the spline curve that will be checked to 
generate to set up the parameter vector \code{u}. It only affects whenever \code{u} is NULL.}

\item{knots}{sequence of knots. (NOTE that this is not the support as in other functions found throughout 
the package \code{modgeom})}

\item{verbose}{if \code{TRUE} it displays progress information.}

\item{prompt.mode}{the mode of projection prompt (i.e. intial parameter values for the algorithm). Possible values are:
\describe{
\item{\strong{distance}}{Candidates footpoints are assigned by their least distances to the data points}
\item{\strong{orthogonal}}{Candidates footpoints are assigned by their degree of orthogonality to the data points}
\item{\strong{directional}}{Candidate footpoints are assigned by the minimum value of the directional functional (see \code{algorithm}) to
the data points}
}}

\item{prompt.begin}{The initial parameter value for the prompting points.}

\item{prompt.end}{The ending parameter value for the prompting points.}

\item{algorithm}{The functional used for the Newton-Raphson approximation. Possible values are:
\describe{
 \item{\strong{Rogers}}{It makes an approximation which employs an expasion series around the current projection (Rogers 1989). }
 \item{\strong{orthogonal}}{It finds the orthogonal points only. The functional tests the inner product of the 
 tangent and the projection vector.}
 \item{\strong{directional}}{The directional algorithm minimizes a function of the distance and orthogonality which is
 controled by a factor
 \code{alpha} (e.g. \code{alpha} = 0 only distance is considered). NOTE: values of \code{alpha} different from zero
 are experimental.}
 \item{\strong{none}}{Only prompt values are kept.}
}}

\item{max.iterations}{Maximum number of allowed iterations.}

\item{alpha}{A value between 0 and 1 that controls the degree of orthogonality that will be included in the directional modes (see \code{algorthim}) and
\code{prompt.mode}). For other modes this parameter has no effect.}

\item{vz}{(experimental) when orthogonality is considered, this vector marks the z direction.}

\item{...}{More arguments passed to \code{\link{interpolate_bspline}}}
}
\value{
A vector of parameter values corresponding to the computed footpoints.
}
\description{
\code{bspline_footpoint} computes the parameter values for the
footpoints of a point set onto the specified spline curve by numerical approximation.
}
\details{
The function initializes the parameter vector \code{u} by brute-force search of closer footpoint candidates whose
number is specified by the user. The candidate footpoints are evenly distributed throughout the curve by default and a Newton-Raphson minimization 
routine ensues in which \code{u} is updated each round through the computation of an increment using different types of functionals.
For a data point and its footpoint these functionals consider the orthogonality of the projection, their distance or 
a combination of both. When both criteria are mixed, their relative contribution is controled by the parameter \code{alpha}, 
e.g. a zero \code{alpha} indicates that orthogonality is not taken into account. 
Initialization can be controled by the user through the \code{prompt.mode}.
}
\examples{
#
# tests the projection quality of data points
# onto a spline curve, user defined
#

# USER PARAMETERS ---------------------------------
require(modgeom)

# the positions which are interpolated
position <- seq(from = 0, to = 10, length.out=800)

c_point <- t( rbind(c(0,1,2,3,3), c(0,3,3,3,3), c(2,1,1,3,4)) )

# the degree
deg <- 3

# the number of data points
n_data <- 40

# the data points
d_point <- t( rbind( runif(n_data)*(max(c_point[,1])-min(c_point[,1]))+min(c_point[,1]), 
                     runif(n_data)*(max(c_point[,2])-min(c_point[,2]))+min(c_point[,2]), 
                     runif(n_data)*(max(c_point[,3])-min(c_point[,3]))+min(c_point[,3])) )


# COMPUTATION -------------------------
# generates the interpolation
R1 <- interpolate_bspline(position, c_point, degree = deg)

# approximated parameters
s1 <- Sys.time()
ap_u <- bspline_footpoint(d_point, c_point, initial.scan.points = 100, 
                          degree=deg, step=.2, tolerance=1e-12, verbose=FALSE, 
                          algorithm="directional", max.iterations=5000, native = FALSE)
s2 <- Sys.time()

ss1 <- Sys.time()
ap_u <- bspline_footpoint(d_point, c_point, initial.scan.points = 100, 
                          degree=deg, step=.2, tolerance=1e-12, verbose=FALSE, 
                          algorithm="directional", max.iterations=5000, native = TRUE)
ss2 <- Sys.time()

r1 <- s2 - s1
r2 <- ss2 - ss1

print(paste("non-native ** native execution times in seconds: " ,r1," ** ",r2, sep=""))


Rd <- interpolate_bspline(ap_u, c_point, degree = deg)

# TEST PROJECTION QUALITY -----------------------
# perpendicularity at the footpoint
proj_angles <- projection_angles(ap_u, d_point, c_point, degree = deg)
print("projection angles ***")
print(proj_angles)


# DRAWING -------------
require(rgl)
draw_projs <- function(x, v){

  points3d(x, pch=2, col=rgb(0,1,0,0), size = 6)

  points3d(v, pch=2, col=rgb(0,1,1,0), size = 6)

  for(i in 1:nrow(x))
  lines3d(rbind(x[i,],v[i,]), col=rgb(0,1,1,0), lty=3, lwd=.5)

}



plot3d(R1, type="l",
       aspect=FALSE, xlab ="x", ylab="y", zlab ="z",
       col=rgb(0,0,.3), lwd=2, main = "cubic spline [clamped]" )

par3d(windowRect=c(184, 130, 813, 666))
#par3d(zoom = 1)

#draws the control points
points3d(c_point, pch=2, col=rgb(1,0.5,0.5), size = 3)
lines3d(c_point, col=rgb(1,0,0), lty=2, lwd=.5)

draw_projs(d_point, Rd)

readline(prompt="Press [enter] to continue")



# tests the projection quality of data points
# onto a B-spline curve, user defined

# USER PARAMETERS ---------------------------------
require(modgeom)

# the positions which are interpolated
position <- seq(from = 0, to = 1, length.out=800)

# the degree
deg <- 3

c_point <- t( rbind(c(0,1,2,3,3), c(0,3,3,3,3), c(2,1,1,3,4)) )
#c_point <- rbind(c_point, c_point[1:deg,])

# the number of data points
n_data <- 40

# the data points
d_point <- t( rbind( runif(n_data)*(max(c_point[,1])-min(c_point[,1]))+min(c_point[,1]), 
                     runif(n_data)*(max(c_point[,2])-min(c_point[,2]))+min(c_point[,2]), 
                     runif(n_data)*(max(c_point[,3])-min(c_point[,3]))+min(c_point[,3])) )


# COMPUTATION -------------------------
# generates the interpolation
R1 <- interpolate_bspline(position, c_point, degree = deg, is.periodic = TRUE)

# approximated parameters
ap_u <- bspline_footpoint(d_point, c_point, 
                          degree=deg, step=1, tolerance=1e-9, verbose=TRUE, algorithm="directional",
                          initial.scan.points=50,
                          max.iterations = 5000, is.periodic = TRUE, native = FALSE) #ap_u
Rd <- interpolate_bspline(ap_u, c_point, degree = deg, is.periodic=TRUE)

# TEST PROJECTION QUALITY -----------------------
# perpendicularity at the footpoint
proj_angles <- projection_angles(ap_u, d_point, c_point, degree = deg, 
                                 is.periodic = TRUE)
print("projection angles ***")
print(proj_angles)


# DRAWING -----
require(rgl)
draw_projs <- function(x, v){
  
  points3d(x, pch=2, col=rgb(0,1,0,0), size = 6)
  
  points3d(v, pch=2, col=rgb(0,1,1,0), size = 6)
  
  for(i in 1:nrow(x))
  lines3d(rbind(x[i,],v[i,]), col=rgb(0,1,1,0), lty=3, lwd=.5)
  
}



plot3d(R1, type="l", 
       aspect=FALSE, xlab ="x", ylab="y", zlab ="z", 
       col=rgb(0,0,.3), lwd=2, main = "cubic spline [periodic]" )

par3d(windowRect=c(184, 130, 813, 666))
#par3d(zoom = 1)

#draws the control points 
points3d(c_point, pch=2, col=rgb(1,0.5,0.5), size = 3)
lines3d(c_point, col=rgb(1,0,0), lty=2, lwd=.5)

draw_projs(d_point, Rd)


}
\author{
Máximo Sánchez-Aragón
}
