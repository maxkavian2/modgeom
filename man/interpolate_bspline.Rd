% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolate_bspline.R
\name{interpolate_bspline}
\alias{interpolate_bspline}
\title{Spline interpolation}
\usage{
interpolate_bspline(
  x,
  v,
  degree = 3,
  derivate = 0,
  knots = seq(from = 0, to = 1, length.out = nrow(v) - degree + 1),
  is.periodic = FALSE,
  unitary = FALSE,
  native = TRUE,
  ...
)
}
\arguments{
\item{x}{The parameter values, as a numeric vector.}

\item{v}{Control points of the spline, as a row-vector matrix of coordinates.}

\item{degree}{The degree of the polynomials that build the spline.}

\item{derivate}{The derivative order to be evaluated. With 0 it just evaluates the
spline at the parameter values (i.e. it does not calculate the derivative)}

\item{knots}{The sequence of knots used for the support, as a numeric vector.
This vector must have a proper length (i.e. number of control points minus degree plus one).
Knots are always ordered in an ascending fashion. (see note below about periodic splines)}

\item{is.periodic}{It specifies if the spline is periodic (\code{TRUE}); otherwise the spline
would be clamped (default).}

\item{unitary}{If \code{TRUE} unitary vectors are returned.}

\item{native}{If \code{TRUE} native code is used (default),}

\item{...}{Parameters passed to the function \code{\link{bspline}}. NOTE that
that function is inner, hence the parameters that can be passed should be described here.}
}
\value{
A matrix containing a set of row-vectors, representing curve positions at the
interpolated parametric values or its derivatives
}
\description{
\code{interpolate_bspline} computes the curve coordinates of
a numeric vector of parameter values or its derivatives.
}
\details{
This function evaluates a spline and finds the coordinates of the
provided parametric values (i.e. interpolation) or its derivatives. Splines
are clamped by default between the lowest and highest knot values. The current implementation selects 
the lowest and the highest knot values to build a new knot sequence of evenly distributed values that 
fulfils the proper number of knots, so deleting the original knot sequence and throwing a warning.
}
\examples{
library(rgl)
 
#the position which is interpolated
position <- seq(from = 0, to = 1, length.out=2000)

# the matrix of control points here
c_point <- t(rbind( c(0, 5, 0, 12, 10, 11, 10, 1, 1, 7),
                    c(4, 12, -7, 3, -5, 10, 4, 8, 9, 10),
                    c(5,  10,  1, 1,  -5,  1, 1, 1, 1, 10 ) ))
# the degree
deg <- 9 

R <- list()
Rtext <- c()
for(dg in 0:(deg-1) ){
  R[[dg+1]] <- interpolate_bspline(position, c_point, degree = deg-dg, native=TRUE)
  Rtext <- rbind(Rtext, interpolate_bspline(.16, c_point, degree = deg-dg, native=TRUE))
}
Rtext[,1] = Rtext[,1]-0.6

colscale <- c("red","gray")
colf <- colorRampPalette(colscale)
cols <- colf(length(R))

#drawing -----
make.chart <- function(tag="", vpar=NULL){
mar.red <- 0.1
options(scipen = 5)
par(mgp=c(2.4,1,.3))
par(mar=c(4,5-mar.red,2.5-mar.red,2-mar.red)+0.1) 
par(cex=1)
  
# 3D pars

  
plot3d(R[[1]], type="l", 
         aspect=TRUE,  
         col=cols[1], lwd=1, main = "", xlab="x", ylab="y", zlab="z", box=FALSE, 
         axes=FALSE)
  
par3d(windowRect=c(150, 150, 750, 750))
#rgl.viewpoint(vpar[1], vpar[2])
view3d(vpar[1], vpar[2])

#par3d(zoom = 0.7)

  axes3d(
    edges=c('x--', 'y--', 'z--'),
    labels=FALSE,
    tick=TRUE, at=c(-4:8)
    
  )
  

if(length(R) > 1)
    for(i in 2:length(R) )
      lines3d(R[[i]], col = cols[i], lwd = 1 )
  
#draws the control points 
points3d( c_point, pch=2, col="gray", size = 6)
  
# prints the texts
labs <- c()
  for(i in deg:1)
  labs <- c(labs, paste("C",as.character(i-1), sep=""))
  
rgl.texts(Rtext[,1], y =Rtext[,2], z=Rtext[,3], labs, col=cols  )


 }
 
cc <- 0
sq <- c(0:90,89:1)
 for(i in sq[sq \%\% length(sq) == 0] ){
  cc <- cc+1
  vpar1 <- c(i,i)
  cst <- as.character(cc)
  if(nchar(cst) == 1) cst <- paste("00",cst, sep="")
  if(nchar(cst) == 2) cst <- paste("0",cst, sep="")
  
  make.chart(tag=paste("angle_",cst,sep=""),vpar=vpar1)
}
rm(i,cc)

library(modgeom)
# the position which is interpolated
position <- seq(from = 0, to = 1-.005, length.out=200)

# the degrees
deg <- 4
c_point_number <- 7

par(mfrow=c(2,2))
for(i in 1:15){
  
  # the matrix of control points here
  a <- rnorm(c_point_number)*20-10;
  b <- rnorm(c_point_number)*20-10;
  c_point <- t (rbind( a, b ) )
  
  rm(a,b)
  
  R1 <- interpolate_bspline(position, c_point, degree = deg, native=TRUE)
  R1p <- interpolate_bspline(position, c_point, degree = deg, is.periodic=TRUE, native=TRUE)
  

  plot(c_point, pch="+", col="red", xlab = "x", ylab = "y",
       main="" )
  lines(c_point, col=rgb(1,0,0,.5), lty="dashed" )
  lines(R1, col=rgb(0,0,0), lwd =2 )

  plot(c_point, pch="+", col="red", xlab = "x", ylab = "y",
       main="" )
  lines(c_point, col=rgb(1,0,0,.5), lty="dashed" )
  lines(R1p, col=rgb(0,0,0), lwd =2 )

}

library(modgeom)

# the position which is interpolated
position <- seq(from = 0, to = 0.995, length.out=200)

# the degree
deg <- 4

# the matrix of control points here
#c_point <- rbind( c(0, 5, 0, 12, 10, 11, 10, 1, 1, 7),
#                  c(4, 12, -7, 3, -5, 10, 4, 8, 9, 9),
#                  c(1,  1,  1, 1,  -5,  1, 1, 1, 1, 10 ) )

c_point <- t( rbind( c(0,2, 5, 0, 0, 5), 
                     c(4, 4, 12,-7,4, 5), 
                     c(12, -12, 1, 1,-12, 1)  ) )

c_point1 <- rbind(c_point,c_point[1:1,])
#c_point2 <- c_point; #rbind(c_point,c_point[1:(deg-1),])


R1 <- interpolate_bspline(position, c_point, degree = deg, is.periodic = TRUE, native=TRUE)
R2 <- interpolate_bspline(position, c_point, degree = deg-1, is.periodic = TRUE, native=TRUE)
R3 <- interpolate_bspline(position, c_point, degree = deg-2, is.periodic = TRUE, native=TRUE)


#drawing -----
require(rgl)

plot3d(R1, type="l", 
       aspect=T, xlab ="x", ylab="y", zlab ="z", 
       col=rgb(0,0,.3), lwd=2, main = "" )

par3d(windowRect=c(184, 130, 813, 666))
#par3d(zoom = 1)

lines3d(R2, col = rgb(0,0,.5), lwd = 2 )
lines3d(R3, col = rgb(0,0,.9), lwd = 2 )

#draws the control points 
points3d( c_point1, pch=2, col=rgb(1,0.5,0.5,.5), size = 3)
lines3d(c_point1, col=rgb(1,0,0,1), lty=2, lwd=.5)

#animates ------
M <- par3d("userMatrix")
if (!rgl.useNULL())
  play3d( par3dinterp(time=(0:2)*1.5,userMatrix=list(M,
                                                     rotate3d(M, pi/2, 1, 0, 0),
                                                     rotate3d(M, pi/2, 0, 1, 0) ) ),          
          duration=6 )
}
\author{
Máximo Sánchez-Aragón
}
