% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bspline_uz_sign.R
\name{bspline_uz_sign}
\alias{bspline_uz_sign}
\title{Signed positions of points projections to spline curves (TG method)}
\usage{
bspline_uz_sign(
  c_points,
  points,
  fp.u = NULL,
  degree = 3,
  tolerance = 1e-09,
  max.iterations = 100,
  initial.scan.points = nrow(c_points) * 8,
  knots = seq(from = 0, to = 1, length.out = nrow(c_points) - degree + 1),
  ap_ref = NULL,
  uz = c(0, 0, 1),
  scan.interval = c(min(knots), max(knots)),
  fp.tolerance = 1e-12,
  fp.max.iterations = 800,
  fp.initial.scan.points = nrow(c_points) * 8,
  fp.algorithm = "directional",
  fp.verbose = FALSE,
  sign.op = "normal",
  ...
)
}
\arguments{
\item{points}{The projected points, as a matrix of row vectors.}

\item{fp.u}{Parameter vector corresponding to the footpoints. If \code{NULL} the algorithm would try to generate
them with parameters fp.* (below). Check the function \code{\link{bspline_footpoint}} for more information about
these parameters.}

\item{degree}{The maximum degree of the spline curve.}

\item{tolerance}{The threshold, as the absolute value of the dot product, below which
the routine ends for each point. The tolerance is applied to each tested point independently.}

\item{max.iterations}{The maximum number of allowed iterations prior to termination. Each test point is evaluated
independently.}

\item{initial.scan.points}{Number of initial points that are scanned when \code{fp.u} is not \code{NULL}.}

\item{knots}{The knot sequence of the spline.}

\item{ap_ref}{The direction (vector of length 3) provided for sign correction, i.e. this vector is used to normalize the 
sign criterium to one direction. This way results from differnet splines may be compared afterwards.}

\item{uz}{The unitary z vector used as criterium of projection for the sign,}

\item{scan.interval}{\emph{[EXPERIMENTAL]} The interval within which the turns are to be found. This interval
would be divided as many times as indicated by \code{initial.scan.points}.}

\item{sign.op}{If 'normal' the full sign operation is retrieved. 'parity' shows only the boolean for
the turn parity only. 'other' represents the other component in the operation, generally
a differential geometry operation. In this case, it is the sign of the vector product of the unitary z vector and 
the tangent.}

\item{...}{Argument passed to \code{\link{interpolate_bspline}}.}

\item{c_point}{The current control points, expressed as a matrix of row vectors.}
}
\value{
A \code{list} of two elements. The first element contains a list of \code{data.frame}s with the parameter values 
corresponding to the turns and additional information. Each \code{data.frame} also contains information about the total 
number of cycles and the final tolerance value, the latter 
being an indication of the turn precision. The second element is a vector with the final sign of all projected points.
}
\description{
This function defines a sign according to the parity of turns and the plane defined by the footpoint projections
and the spline tangent vectors (at the footpoint), described in the PhD thesis as the tangent plane method (TG).

This function specifically depends on tensorA package. The current evaluation only works
for three dimensional space, i.e. all row-vector matrices defining positions must have three columns.
}
\examples{


# USER PARAMETERS -------------------------
require(modgeom)
# comes from the processing in bspline2_test8 example.
# temporary libPath selection
load(paste(.libPaths()[1],"/modgeom/extdata/bspline_uz_turns_data",sep=""))
#load("examples/bspline_uz_turns_data") # comes from the processing in bspline2_test8 example.
#load("extdata/bspline_uz_turns_data") # comes from the processing in bspline2_test8 example.

deg <- 3
#c_points <- rbind(c_points,c(2.5,-1,2))
vec_shift_value=2
c_points <- rbind( c(0,0,-.5),c(-1,0,-.5),c(-1,1,0), c(2,1,1) ,c(4,1,0),c(4,0,-.5),c(3,0,-.5) )

for(j in 1:nrow(c_points))
  c_points[j,3] <- c_points[j,3] + vec_shift_value

u <- seq(from = 0, to = 1, length.out=100)
points <- interpolate_bspline(u, c_points, degree = deg)
ref_point <- c(4,1,1)    # the reference observation point
ref_point_alt <- ref_point[length(ref_point):1]

# we need to define also the points that will be projected
n <- 80 # the number of points that will be projected
dev <- 1  # the deviation in the test points
cell.points <- cbind( runif(2*n, min=-dev, max=dev), 
                 runif(2*n, min=-dev, max=dev), 
                 runif(2*n, min=-dev, max=dev) )

#rm(n)
rM <- c()
for(i in 1:n)
  rM <- rbind(rM, ref_point)
for(i in (n+1):(2*n))
  rM <- rbind(rM, ref_point_alt)

#cell.points <- rbind(cell.points, cell.points)
cell.points <- cell.points + rM
rm(rM,i)
rm(n)

# checks the turns function detection ----------------
ftpt_u <- bspline_footpoint(cell.points, c_points, degree = deg, algorithm="directional",
                            tolerance=1e-12, max.iterations = 800, initial.scan.points=nrow(c_points)*100)

ftpoints <- interpolate_bspline(ftpt_u, c_points, degree = deg)


multiplier <- 2000
start.time1 <- Sys.time()
signv <- bspline_uz_sign (
          c_points,
          cell.points,
          fp.u = NULL,
          degree = deg,
          tolerance=1e-15,
          fp.tolerance=1e-12,
          max.iterations = 1500,
          initial.scan.points=nrow(c_points)*multiplier,
          uz = c(0,1,0),
          fp.verbose=TRUE
)
signv_xor <- signv[[2]]
u_turn2_data <- signv[[1]]
end.time1 <- Sys.time()
end.time1 <- start.time1 - end.time1
print(paste("procedure lasted: ",-end.time1))


# GRAPHICS --------------------------------------
d3graphics <- function (signv, tag, vpar = c(0,0)){
  #attach(loaded.data)
  require(rgl)
  
  cls <- rep("red", times=nrow(cell.points))
  cls[signv] <- "blue"
  

  
  plot3d(loaded.data$R_fuzzy, type="n", xlab="x", ylab="y", zlab="z")
  #points3d(R_fuzzy, col="yellowgreen", size=3, pch=21, bg="red" )
  par3d(windowRect=c(150, 150, 700, 700))
  #rgl.viewpoint(vpar[1], vpar[2])
  view3d(vpar[1],vpar[2])
  #par3d(zoom = 1)
  
  
  #points3d(t(as.matrix(ref_point)), col="red", size=8)
  points3d(c_points, col="lightblue4", size=4)
  lines3d(c_points, col="lightblue4", lty="dotted", lwd=.5)
  lines3d(points, col="lightblue4", lwd=2) # points of the spline curve
  sgs <- c();

  for(j in 1:length(u_turn2_data)){
    if(nrow(u_turn2_data[[j]]) > 0){
      
      tp <- interpolate_bspline (u_turn2_data[[j]]$u.found, c_points, degree=deg)
      
      clst <- cls[j]
      
      lines3d( rbind(cell.points[j,],ftpoints[j,]), col=clst, lwd=.01)
      
      points3d( tp,  col="green", size = 6  )
    }
  }
  
  points3d( cell.points, col=cls , size = 6 )
  v0 <- interpolate_bspline (0, c_points, degree=deg, derivate=0)
  v1 <- interpolate_bspline (0, c_points, degree=deg, derivate=1)
  v1 <- v1 / (2*sqrt(sum(v1^2)) )
  v1 <- v0 + v1
  arrow3d(v0, v1, 1/20, width=1/4, thickness=1/10)
  rm(tp)
  #detach(loaded.data)
}

cc <- 0
sq <- c(0:90,89:1)
i = sq[sq \%\% 10 == 0][1]
cc <- cc+1
vpar1 <- c(i,i)
cst <- as.character(cc)
if(nchar(cst) == 1) cst <- paste("00",cst, sep="")
if(nchar(cst) == 2) cst <- paste("0",cst, sep="")
  
d3graphics(signv_xor, paste("xor_scalar_parity_",cst,sep=""),vpar=vpar1)

rm(i,cc)


}
\author{
Máximo Sánchez-Aragón
}
